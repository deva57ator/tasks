const http = require('node:http');
const { URL } = require('node:url');

function createApp() {
  const stack = [];

  function addLayer(layer) {
    stack.push(layer);
  }

  function use(path, handler) {
    if (typeof path === 'function' || isRouter(path)) {
      handler = path;
      path = '/';
    }
    if (isRouter(handler)) {
      for (const layer of handler._stack) {
        if (layer.type === 'route') {
          const newPath = joinPaths(path, layer.path || '/');
          const compiled = createPathMatcher(newPath);
          addLayer({
            ...layer,
            path: newPath,
            matcher: compiled.matcher,
            keys: compiled.keys
          });
        } else if (layer.type === 'middleware') {
          const newPath = joinPaths(path, layer.path || '/');
          addLayer({
            ...layer,
            path: newPath,
            matcher: createPrefixMatcher(newPath)
          });
        }
      }
      return app;
    }
    if (Array.isArray(handler)) {
      for (const h of handler) {
        use(path, h);
      }
      return app;
    }
    if (typeof handler !== 'function') {
      throw new TypeError('Middleware must be a function');
    }
    addLayer({ type: 'middleware', path, handler, keys: [], matcher: createPrefixMatcher(path) });
    return app;
  }

  function registerRoute(method, path, handlers) {
    const flat = handlers.flat();
    if (!flat.length) {
      throw new Error('Route handlers are required');
    }
    for (const h of flat) {
      if (typeof h !== 'function') {
        throw new TypeError('Route handler must be a function');
      }
    }
    addLayer({
      type: 'route',
      method,
      path,
      handlers: flat,
      ...createPathMatcher(path)
    });
    return app;
  }

  const app = function handler(req, res, out) {
    handleRequest(req, res, out);
  };

  function handleRequest(req, res, out) {
    extendResponse(res);
    const url = new URL(req.url || '/', 'http://localhost');
    req.originalUrl = req.url;
    req.path = url.pathname;
    req.query = Object.create(null);
    for (const [key, value] of url.searchParams.entries()) {
      if (Object.prototype.hasOwnProperty.call(req.query, key)) {
        const current = req.query[key];
        if (Array.isArray(current)) {
          current.push(value);
        } else {
          req.query[key] = [current, value];
        }
      } else {
        req.query[key] = value;
      }
    }
    req.params = {};
    req.body = undefined;
    req._body = false;

    let index = 0;

    function next(err) {
      if (res.writableEnded) {
        return;
      }
      if (index >= stack.length) {
        if (typeof out === 'function') {
          return out(err);
        }
        if (err) {
          res.status(err.status || err.statusCode || 500);
          const payload = { error: { code: err.code || 'internal_error', message: err.message || 'Internal Server Error' } };
          res.json(payload);
        } else {
          res.status(404).json({ error: { code: 'not_found', message: 'Not Found' } });
        }
        return;
      }
      const layer = stack[index++];
      if (layer.type === 'middleware') {
        const match = layer.matcher(req.path);
        if (!match) {
          return next(err);
        }
        if (err) {
          if (layer.handler.length === 4) {
            return layer.handler(err, req, res, next);
          }
          return next(err);
        }
        if (layer.handler.length === 4) {
          return next();
        }
        try {
          return layer.handler(req, res, next);
        } catch (error) {
          return next(error);
        }
      } else if (layer.type === 'route') {
        if (layer.method !== req.method) {
          return next(err);
        }
        const match = layer.matcher(req.path);
        if (!match) {
          return next(err);
        }
        req.params = match.params;
        runHandlers(layer.handlers, 0, err);
      }
    }

    function runHandlers(handlers, i, err) {
      if (res.writableEnded) {
        return;
      }
      if (i >= handlers.length) {
        return next(err);
      }
      const handler = handlers[i];
      if (err) {
        if (handler.length === 4) {
          try {
            return handler(err, req, res, (nextErr) => runHandlers(handlers, i + 1, nextErr));
          } catch (error) {
            return runHandlers(handlers, i + 1, error);
          }
        }
        return runHandlers(handlers, i + 1, err);
      }
      if (handler.length === 4) {
        return runHandlers(handlers, i + 1, err);
      }
      try {
        return handler(req, res, (routeErr) => runHandlers(handlers, i + 1, routeErr));
      } catch (error) {
        return runHandlers(handlers, i + 1, error);
      }
    }

    next();
  }

  app.use = function (...args) {
    use(...args);
    return app;
  };

  ['get', 'post', 'put', 'patch', 'delete'].forEach((method) => {
    app[method] = function (path, ...handlers) {
      return registerRoute(method.toUpperCase(), path, handlers);
    };
  });

  app.listen = function (port, host, callback) {
    const server = http.createServer((req, res) => app(req, res));
    return server.listen(port, host, callback);
  };

  app._stack = stack;
  app.handle = handleRequest;

  return app;
}

function extendResponse(res) {
  if (res._expressExtended) return;
  res._expressExtended = true;
  res.status = function (code) {
    res.statusCode = code;
    return res;
  };
  res.set = function (field, value) {
    if (typeof field === 'object') {
      for (const [key, val] of Object.entries(field)) {
        res.setHeader(key, val);
      }
      return res;
    }
    res.setHeader(field, value);
    return res;
  };
  res.json = function (data) {
    if (!res.getHeader('Content-Type')) {
      res.setHeader('Content-Type', 'application/json; charset=utf-8');
    }
    res.end(JSON.stringify(data));
  };
  res.send = function (data) {
    if (Buffer.isBuffer(data) || typeof data === 'string') {
      res.end(data);
      return;
    }
    res.json(data);
  };
}

function createPrefixMatcher(path) {
  if (!path || path === '/' || path === '*') {
    return () => ({ params: {} });
  }
  const normalized = normalizePath(path);
  return (requestPath) => {
    if (requestPath === normalized) return { params: {} };
    if (requestPath.startsWith(normalized.endsWith('/') ? normalized : normalized + '/')) {
      return { params: {} };
    }
    return null;
  };
}

function createPathMatcher(path) {
  const { regex, keys } = compilePath(path);
  return {
    matcher: (requestPath) => {
      const match = regex.exec(requestPath);
      if (!match) return null;
      const params = {};
      keys.forEach((key, idx) => {
        params[key] = decodeURIComponentSafe(match[idx + 1] || '');
      });
      return { params };
    },
    keys
  };
}

function compilePath(path) {
  if (!path) path = '/';
  const keys = [];
  let pattern = '^';
  const segments = normalizePath(path).split('/').filter(Boolean);
  if (segments.length === 0) {
    pattern += '/?$';
  } else {
    pattern += '/';
    pattern += segments
      .map((segment) => {
        if (segment.startsWith(':')) {
          const key = segment.slice(1);
          keys.push(key);
          return '([^/]+)';
        }
        if (segment === '*') {
          keys.push('wild');
          return '(.*)';
        }
        return escapeRegex(segment);
      })
      .join('/');
    pattern += '/?$';
  }
  const regex = new RegExp(pattern);
  return { regex, keys };
}

function escapeRegex(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

function normalizePath(path) {
  if (!path) return '/';
  if (path === '/') return '/';
  let normalized = path;
  if (!normalized.startsWith('/')) normalized = '/' + normalized;
  normalized = normalized.replace(/\/+/g, '/');
  if (normalized.length > 1 && normalized.endsWith('/')) {
    normalized = normalized.slice(0, -1);
  }
  return normalized;
}

function decodeURIComponentSafe(value) {
  try {
    return decodeURIComponent(value);
  } catch {
    return value;
  }
}

function joinPaths(base, addition) {
  if (!base) return addition;
  if (!addition) return base;
  const normalizedBase = normalizePath(base);
  const normalizedAddition = normalizePath(addition);
  if (normalizedBase === '/') return normalizedAddition;
  if (normalizedAddition === '/') return normalizedBase;
  return (normalizedBase + normalizedAddition).replace(/\/+/g, '/');
}

function isRouter(obj) {
  return obj && typeof obj === 'function' && Array.isArray(obj._stack);
}

function parseLimit(value) {
  if (typeof value === 'number') return value;
  if (typeof value !== 'string') return 1024 * 1024;
  const trimmed = value.trim().toLowerCase();
  const match = /^([0-9.]+)\s*(kb|mb|gb|b)?$/.exec(trimmed);
  if (!match) return 1024 * 1024;
  const size = parseFloat(match[1]);
  const unit = match[2] || 'b';
  switch (unit) {
    case 'gb':
      return Math.floor(size * 1024 * 1024 * 1024);
    case 'mb':
      return Math.floor(size * 1024 * 1024);
    case 'kb':
      return Math.floor(size * 1024);
    default:
      return Math.floor(size);
  }
}

function json(options = {}) {
  const limit = parseLimit(options.limit || 1024 * 1024);
  return function jsonMiddleware(req, res, next) {
    if (req._body) return next();
    const type = req.headers['content-type'] || '';
    if (!type.includes('application/json')) {
      return next();
    }
    let length = 0;
    const chunks = [];
    req.on('data', (chunk) => {
      length += chunk.length;
      if (length > limit) {
        req.destroy();
        const err = new Error('Payload too large');
        err.status = 413;
        next(err);
        return;
      }
      chunks.push(chunk);
    });
    req.on('end', () => {
      if (res.writableEnded) return;
      req._body = true;
      const buffer = Buffer.concat(chunks);
      if (buffer.length === 0) {
        req.body = {};
        return next();
      }
      try {
        const text = buffer.toString(options.encoding || 'utf8');
        req.body = text ? JSON.parse(text) : {};
        next();
      } catch (err) {
        err.status = 400;
        err.code = 'invalid_json';
        next(err);
      }
    });
    req.on('error', (err) => {
      next(err);
    });
  };
}

function Router() {
  const app = createApp();
  app.listen = undefined;
  app._isRouter = true;
  return app;
}

module.exports = Object.assign(createApp, {
  json,
  Router
});
